<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLE加速度データ受信</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* --- Design System -------------------------------------------------- */
    :root {
      --bg: #0b0c10;
      --panel: #12141a;
      --card: #161922;
      --text: #e9eef5;
      --muted: #9aa7b5;
      --primary: #3b82f6;
      --danger: #ef4444;
      --success: #22c55e;
      --warning: #f59e0b;
      --ring: rgba(59,130,246,.45);
      --shadow: 0 6px 24px rgba(0,0,0,.35), 0 1px 0 rgba(255,255,255,.05) inset;
      --radius: 16px;
      --radius-sm: 12px;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f4f6fb;
        --panel: #ffffff;
        --card: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --shadow: 0 6px 24px rgba(2,6,23,.06), 0 1px 0 rgba(2,6,23,.04) inset;
      }
    }

    /* Base */
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 10% -10%, rgba(59,130,246,.08), transparent 60%),
                  radial-gradient(1200px 600px at 90% -10%, rgba(34,197,94,.08), transparent 60%),
                  var(--bg);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px clamp(16px, 3vw, 32px);
    }

    /* Header */
    .app-header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 16px;
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px 20px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    .title {
      font-size: clamp(18px, 2.4vw, 24px);
      font-weight: 700;
      letter-spacing: .02em;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 999px; font-size: 12px; font-weight: 600;
      color: #fff; background: linear-gradient(90deg, var(--primary), #22c55e);
    }

    /* Controls */
    .controls {
      margin-top: 18px;
      display: grid;
      grid-template-columns: 1.2fr 2fr auto;
      gap: 16px;
    }

    .action-card {
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: grid; gap: 12px;
      align-content: center;
    }

    .button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    .main-btn {
      font-size: clamp(16px, 2.1vw, 20px);
      padding: 14px 18px;
      border-radius: 12px; border: none;
      font-weight: 700; letter-spacing: .02em;
      cursor: pointer;
      color: #fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .18s ease, box-shadow .18s ease, opacity .18s ease;
    }
    .main-btn:active { transform: translateY(1px); }
    .start-btn { background: linear-gradient(180deg, #22c55e, #16a34a); }
    .stop-btn  { background: linear-gradient(180deg, #ef4444, #b91c1c); }
    .send-btn  { background: linear-gradient(180deg, #3b82f6, #1d4ed8); }
    .main-btn:disabled { opacity: .55; filter: grayscale(.2); cursor: not-allowed; }

    .status-card {
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: grid; gap: 8px;
      align-content: center;
    }
    .status-grid { display: grid; grid-template-columns: .9fr 1.1fr; gap: 8px 12px; align-items: center; }
    .status-label { color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .08em; }
    .status-value { font-weight: 700; }

    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }

    .setting-panel { display: grid; gap: 14px; }
    .setting-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 12px;
      align-items: end;
    }
    .field { display: grid; gap: 6px; }
    .field label { font-size: 12px; color: var(--muted); letter-spacing: .03em; }
    .field input, .field select {
      appearance: none;
      background: var(--card);
      border: 1px solid rgba(148,163,184,.22);
      border-radius: 10px; color: var(--text);
      padding: 10px 1px; font-size: 14px;
      box-shadow: 0 0 0 0 var(--ring);
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
      width: 100%;
      text-align: center
    }
    .field input[type=number] {
      text-align: right;
    }
    .field input:focus, .field select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 6px var(--ring);
    }

    .threshold-row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }

    .send-row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: end; }

    /* Chart + Output */
    .content {
      margin-top: 18px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }
    .card { background: var(--panel); border-radius: var(--radius); box-shadow: var(--shadow); }
    .card-header { padding: 14px 16px; border-bottom: 1px solid rgba(148,163,184,.18); display:flex; align-items:center; justify-content:space-between; }
    .card-title { font-weight: 700; }
    .card-body { padding: 12px 16px 16px; }

    #chart { width: 100%; height: 360px; display:block; }
    #output {
      height: 360px; overflow: auto; background: var(--card);
      border-radius: 0 0 var(--radius) var(--radius);
      margin: 0; padding: 12px 14px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px;
      border: 1px solid rgba(148,163,184,.18); border-top: none;
      white-space: pre-wrap; 
    }

    /* Tablet/Desktop scaling */
    @media (min-width: 640px) { body { font-size: 16px; } }
    @media (min-width: 768px) { body { font-size: 17.5px; } }
    @media (min-width: 1024px) { body { font-size: 18.5px; } }

    /* Mobile layout */
    @media (max-width: 900px) {
      .controls { grid-template-columns: 1fr; }
      .content  { grid-template-columns: 1fr; }
      .setting-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }

    /* ---- 計測中UI強調 ---- */
    .badge.active {
      background: linear-gradient(90deg, #ef4444, #b91c1c);
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: .75; }
    }

    /* 計測中は背景に赤みを乗せる（bodyにmeasuring-modeを付け外し） */
    body.measuring-mode {
      background:
        radial-gradient(1200px 600px at 10% -10%, rgba(239,68,68,.10), transparent 60%),
        radial-gradient(1200px 600px at 90% -10%, rgba(239,68,68,.10), transparent 60%),
        var(--bg);
    }

    /* タイマーを強調（クラス付け外し） */
    #timer.measuring {
      font-size: 24px;
      color: var(--danger);
      font-weight: 800;
      letter-spacing: .02em;
    }

  </style>
</head>
<body>
  <div class="container">
    <header class="app-header">
      <div class="title">BLE加速度データ受信 <span class="badge">Live</span></div>
      <div class="status-grid">
        <div class="status-label">状態</div><div id="now" class="status-value">未接続</div>
        <div class="status-label">タイマー</div><div id="timer" class="status-value">停止中</div>
      </div>
    </header>

    <!-- Controls Row -->
    <section class="controls">
      <div class="action-card">
        <div class="button-row">
          <button id="start" class="main-btn start-btn">▶ スタート</button>
          <button id="stop" class="main-btn stop-btn">■ ストップ</button>
          <button id="connect" class="main-btn" style="margin-bottom:8px; background: linear-gradient(180deg, #2563eb, #1e40af);">🔗 接続</button>
          <button id="reset" class="main-btn" style="margin-bottom:8px; background: linear-gradient(180deg, #f59e0b, #b45309);">⟲ リセット</button>
        </div>
      </div>

      <div class="panel">
        <div class="setting-panel">
          <div class="setting-grid">
            <div class="field">
              <label for="axis">軸</label>
              <select id="axis">
                <option value="all">すべて</option>
                <option value="x">X</option>
                <option value="y">Y</option>
                <option value="z">Z</option>
              </select>
            </div>
            <div class="field">
              <label for="threshold">しきい値</label>
              <div class="threshold-row">
                <input type="number" step="0.01" id="threshold" value="1.00" />
              </div>
            </div>
            <div class="field">
              <label for="count">回数</label>
              <input type="number" id="count" value="10" min="1" />
            </div>
            <div class="field">
              <label>成型機加工サイクル (秒):
                <input type="number" id="machine_duration" value="10" min="1" max="120" step="1">
              </label>
            </div>
            <div class="field">
              <label>ロボットアーム動作時間 (秒):
                <input type="number" id="duration" value="1" min="1" max="120" step="1">
              </label>
            </div>
            <div class="field">
              <label>&nbsp;</label>
              <button id="sendSetting" class="main-btn send-btn">設定送信</button>
            </div>
          </div>
        </div>
      </div>

      <div class="status-card">
        <div class="status-grid">
          <div class="status-label">受信件数</div><div id="rxCount" class="status-value">0</div>
          <div class="status-label">しきい値</div><div id="thLabel" class="status-value">1.00</div>
        </div>
      </div>
    </section>

    <!-- Content Row -->
    <section class="content">
      <article class="card">
        <div class="card-header">
          <div class="card-title">リアルタイム波形</div>
        </div>
        <div class="card-body">
          <canvas id="chart"></canvas>
        </div>
      </article>

      <aside class="card" style="overflow:hidden;">
        <div class="card-header">
          <div class="card-title">ログ</div>
        </div>
        <pre id="output" class="card-body"></pre>
      </aside>
    </section>
  </div>

  <script>
    // ------------------ 既存ロジック（最小変更） ------------------
    let bleDevice, rxChar, txChar;
    let dataLog = [];

    // ACK送信用のキュー
    let ackQueue = [];
    let isSendingAck = false;

    let chartInitialized = false;
    let chart;

    const $ = (id) => document.getElementById(id);

    window.onload = () => {
      if (!('bluetooth' in navigator)) {
        display('[エラー] このブラウザはWeb Bluetoothに対応していません（Chrome系 + HTTPS/localhost 推奨）');
      }
      $('connect').disabled    = false;
      $('reset').disabled      = true;
      $('start').disabled      = true;
      $('stop').disabled       = true;
      $("now").textContent = "未接続";
    };

    function isConnected() {
      return !!(bleDevice?.gatt?.connected && rxChar && txChar);
    }

    // 計測中UIの切り替え
    function setMeasuring(on) {
      // バッジの強調
      const badge = document.querySelector('.badge');
      if (badge) {
        badge.textContent = on ? '計測中' : 'Live';
        badge.classList.toggle('active', on);
      }

      // 画面全体の背景トーン
      document.body.classList.toggle('measuring-mode', on);

      // タイマーの強調
      $('timer')?.classList.toggle('measuring', on);

      // 画面タイトルにも状態を反映（任意：先頭に●を付ける）
      document.title = (on ? '● ' : '') + 'BLE加速度データ受信（改善版）';

      // ボタン状態（運用ポリシーに合わせ調整可能）
      // 計測中は reset 無効にして誤操作を防ぐ
      if ($('reset')) $('reset').disabled = !!on;
    }

    function initChart() {
      if (chart) chart.destroy();

      const canvas = $('chart');
      const ctx = canvas.getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'X',
              data: [],
              borderColor: '#ef9ca3',
              borderWidth: 2,
              pointRadius: 0,
              fill: false,
              segment: {
                borderColor: c => {
                  const y1 = c.p0.parsed.y; const y2 = c.p1.parsed.y;
                  const isOver = thresholdY >= 0 ? (y1 > thresholdY || y2 > thresholdY) : (y1 < thresholdY || y2 < thresholdY);
                  return isOver ? '#ef4444' : '#ef9ca3';
                }
              }
            },
            {
              label: 'Y',
              data: [],
              borderColor: '#86efac',
              borderWidth: 2,
              pointRadius: 0,
              fill: false,
              segment: {
                borderColor: c => {
                  const y1 = c.p0.parsed.y; const y2 = c.p1.parsed.y;
                  const isOver = thresholdY >= 0 ? (y1 > thresholdY || y2 > thresholdY) : (y1 < thresholdY || y2 < thresholdY);
                  return isOver ? '#22c55e' : '#86efac';
                }
              }
            },
            {
              label: 'Z',
              data: [],
              borderColor: '#93c5fd',
              borderWidth: 2,
              pointRadius: 0,
              fill: false,
              segment: {
                borderColor: c => {
                  const y1 = c.p0.parsed.y; const y2 = c.p1.parsed.y;
                  const isOver = thresholdY >= 0 ? (y1 > thresholdY || y2 > thresholdY) : (y1 < thresholdY || y2 < thresholdY);
                  return isOver ? '#3b82f6' : '#93c5fd';
                }
              }
            }
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { suggestedMin: -2, suggestedMax: 2, grid: { color: 'rgba(148,163,184,.2)' } },
            x: { ticks: { display: false }, grid: { color: 'rgba(148,163,184,.12)' } }
          },
          plugins: { customThreshold: {} }
        }
      });

      chartInitialized = true;
    }

    let thresholdY = 1.25;
    let isDragging = false;

    const thresholdPlugin = {
      id: 'customThreshold',
      afterDraw(chart) {
        const yScale = chart.scales.y;
        if (!yScale) return;
        const y = yScale.getPixelForValue(thresholdY);
        const ctx = chart.ctx;
        const {left, right} = chart.chartArea;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
        ctx.strokeStyle = 'rgba(239,68,68,.9)';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([6,6]);
        ctx.stroke();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text');
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText(`しきい値: ${thresholdY.toFixed(2)}`, left + 8, y - 8);
        ctx.restore();
      }
    };
    Chart.register(thresholdPlugin);

    const canvasEl = $('chart');
    canvasEl.addEventListener('mousedown', e => {
      if (!chart) return;
      const rect = canvasEl.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const threshY = chart.scales.y.getPixelForValue(thresholdY);
      if (Math.abs(y - threshY) < 8) isDragging = true;
    });
    canvasEl.addEventListener('mousemove', e => {
      if (isDragging && chart) {
        const rect = canvasEl.getBoundingClientRect();
        const y = e.clientY - rect.top;
        thresholdY = chart.scales.y.getValueForPixel(y);
        $('threshold').value = thresholdY.toFixed(2);
        $('thLabel').textContent = thresholdY.toFixed(2);
        chart.update('none');
        updateAutoCount();
      }
    });
    canvasEl.addEventListener('mouseup', () => isDragging = false);
    canvasEl.addEventListener('mouseleave', () => isDragging = false);
    
    let startTime = null;
    let timerInterval = null;

    function startTimerInterval() {
      stopTimerInterval();
      timerInterval = setInterval(() => {
        if (startTime) {
          const now = Date.now();
          const elapsed = Math.floor((now - startTime) / 1000);
          $('timer').textContent = `計測中: ${elapsed}秒`;
        }
      }, 200);
    }
    function stopTimerInterval() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function display(line) {
      const el = $('output');
      el.insertAdjacentText('beforeend', line + '\n'); // 常にテキストで追記
      el.scrollTop = el.scrollHeight;
    }

    // 接続ボタン
    $('connect').onclick = async () => {
      try {
        await connect();
        $('now').textContent   = '接続済み';
        $('connect').disabled    = true;
        $('reset').disabled      = false;
        $('start').disabled      = false;
        // stopは計測開始後にのみ有効化する
      } catch (e) {
        display('[エラー] 接続失敗: ' + (e?.message || e));
      }
    };

    $('start').onclick = async () => {
      try {
        if (!isConnected()) {
          display('[エラー] 先に接続してください（接続ボタンを押してください）');
          return;
        }
        await sendCommand('START');
        dataLog = [];
        resetChartData();
        display('[開始コマンド送信]');
        startTime = Date.now();
        $('timer').textContent = '計測中: 0秒';
        $('now').textContent   = '計測中';
        startTimerInterval();
        setMeasuring(true);
        $('start').disabled = true;
        $('stop').disabled  = true; // ← ここは計測プロトコルに合わせて true/false を選択
        // ※ STOP を許可するなら false に
        $('stop').disabled  = false;
      } catch (err) {
        display('[エラー] ' + err.message);
      }
    };

    $('stop').onclick = async () => {
      await sendCommand('STOP');
      display('[停止コマンド送信]');
      $('now').textContent = '停止中';
      stopTimerInterval();
      setMeasuring(false);
      $('stop').disabled = true;
    };

    async function connect() {
      bleDevice = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'XIAO' }],
        optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e']
      });

      bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

      const server = await bleDevice.gatt.connect();
      const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
      rxChar = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
      txChar = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');
      await rxChar.startNotifications();
      rxChar.addEventListener('characteristicvaluechanged', handleReceive);
      $('now').textContent = '接続済み';
      if (!chartInitialized) initChart();
    }

    // ACKをキューに入れて送信
    async function queueAck() {
      ackQueue.push('ACK');
      processAckQueue();
    }
    async function processAckQueue() {
      if (isSendingAck || ackQueue.length === 0) return;
      isSendingAck = true;
      const encoder = new TextEncoder();
      while (ackQueue.length > 0) {
        try {
          await txChar.writeValue(encoder.encode(ackQueue.shift() + "\n"));
          await new Promise(res => setTimeout(res, 20));
        } catch (err) {
          console.error('ACK送信エラー:', err);
        }
      }
      isSendingAck = false;
    }

    async function sendCommand(text) {
      const encoder = new TextEncoder();
      await txChar.writeValue(encoder.encode(text + "\n"));
    }

    async function handleReceive(event) {
      const data = event.target.value;
      const byteLength = data.byteLength;

      if (byteLength === 6) {
        const dv = new DataView(data.buffer);
        const ax = dv.getInt16(0, false) / 100.0;
        const ay = dv.getInt16(2, false) / 100.0;
        const az = dv.getInt16(4, false) / 100.0;

        dataLog.push({ ax, ay, az });
        $('rxCount').textContent = dataLog.length;

        if (!chartInitialized) initChart();
        chart.data.labels.push(dataLog.length);
        chart.data.datasets[0].data.push(ax);
        chart.data.datasets[1].data.push(ay);
        chart.data.datasets[2].data.push(az);
        chart.update('none');

        updateAutoCount();
        queueAck();
        return;
      }

      const value = new TextDecoder().decode(event.target.value).trim();
      if (value === 'STARTED') {
        display('[XIAO] 計測開始');
      } else if (value === 'STOPPED') {
        display('[XIAO] 計測停止');
      } else if (value === 'ENDED') {
        display('データ受信完了！');
        setMeasuring(false);
        $('reset').disabled = false;
        if (dataLog.length === 0) {
          display('[警告] 受信データがありません。');
          return;
        }

        // 各軸の最大・最小と行番号
        let maxX = -Infinity, minX = Infinity, maxXRow = -1, minXRow = -1;
        let maxY = -Infinity, minY = Infinity, maxYRow = -1, minYRow = -1;
        let maxZ = -Infinity, minZ = Infinity, maxZRow = -1, minZRow = -1;

        dataLog.forEach((row, idx) => {
          if (row.ax > maxX) { maxX = row.ax; maxXRow = idx; }
          if (row.ax < minX) { minX = row.ax; minXRow = idx; }
          if (row.ay > maxY) { maxY = row.ay; maxYRow = idx; }
          if (row.ay < minY) { minY = row.ay; minYRow = idx; }
          if (row.az > maxZ) { maxZ = row.az; maxZRow = idx; }
          if (row.az < minZ) { minZ = row.az; minZRow = idx; }
        });

        // 表示用HTML生成
        let html = '';
        dataLog.forEach((row, idx) => {
          const format = (val, isMax, isMin) => {
            if (isMax) return `<span style="color:#ef4444">${val.toFixed(2)}</span>`;
            if (isMin) return `<span style="color:#3b82f6">${val.toFixed(2)}</span>`;
            return val.toFixed(2);
          };
          const xVal = format(row.ax, idx === maxXRow, idx === minXRow);
          const yVal = format(row.ay, idx === maxYRow, idx === minYRow);
          const zVal = format(row.az, idx === maxZRow, idx === minZRow);
          html += `x:${xVal} y:${yVal} z:${zVal}<br>`;
        });
        $('output').innerHTML += html;

      } else if (value.startsWith('THR_OK')) {
        display("[情報] しきい値設定が完了しました。デバイスは切断します。");

        // UIも強制的に切断状態に遷移
        onDisconnected();
        
        // デバイスオブジェクトが残っていればこちらから切断要求
        if (bleDevice && bleDevice.gatt.connected) {
          bleDevice.gatt.disconnect();
        }
        return;
      }else if (value.startsWith('ERROR')) {
        display('[エラー] ' + value);
      } else {
        console.warn('未知の文字列データ:', value);
      }
    }

    $("sendSetting").onclick = async () => {
      const axis = $("axis").value;
      const threshold = parseFloat($("threshold").value);
      const count = parseInt($("count").value, 10);

      // 秒 → ms
      let durationSec = parseInt($("duration").value, 10);
      let machineSec  = parseInt($("machine_duration").value, 10);

      if (axis == "all" ) return display("[エラー] 軸を１つ選択してください");
      if (count < 1 || count > 11) return display("[エラー] 回数は1〜10回で指定してください");
      if (durationSec < 1 || durationSec > 120) return display("[エラー] 動作時間は1〜120秒で指定してください");
      if (machineSec  < 1 || machineSec  > 120) return display("[エラー] サイクル時間は1〜120秒で指定してください");

      const duration = durationSec * 1000;
      const machine_duration = machineSec * 1000;

      const command = `THR,${axis},${threshold},${count},${duration},${machine_duration}\n`;

      try {
        if (!txChar) {
          display("[エラー] 先にBLE接続が必要です");
          return;
        }
        const encoder = new TextEncoder();
        await txChar.writeValue(encoder.encode(command));
        display(`[設定送信] ${command.trim()}`);
      } catch (e) {
        display(`[エラー] 設定送信失敗: ${e.message}`);
      }
    };

    $('threshold').addEventListener('input', e => {
      const val = parseFloat(e.target.value);
      if (!isNaN(val)) {
        thresholdY = val;
        $('thLabel').textContent = thresholdY.toFixed(2);
        chart?.update('none');
        updateAutoCount();
      }
    });

    function updateVisibleDatasets() {
      const selected = $('axis').value;
      if (!chart) return;
      chart.data.datasets.forEach((ds, idx) => {
        const axis = ['x', 'y', 'z'][idx];
        ds.hidden = (selected !== 'all' && selected !== axis);
      });
      chart.update('none');
    }
    $('axis').addEventListener('change', ()=>{ updateVisibleDatasets(); updateAutoCount(); });

    // === 自動回数カウント（しきい値超えラン数 → 回数に反映） ===
    function isOverThreshold(v, th){ return th >= 0 ? (v > th) : (v < th); }
    function countRunsOverThreshold(arr, th){ 
      let cnt=0, prev=false; 
      for(let i=0;i<arr.length;i++){ 
        const cur=isOverThreshold(arr[i], th); 
        if(cur && !prev) cnt++; prev=cur; 
      } return cnt; 
    }
    function updateAutoCount(){ 
      if(!chart) return;
      const sel=$('axis')?.value||'y'; 
      const idx= sel==='x'?0 : sel==='y'?1 : sel==='z'?2 : 1; 
      const dataArr=chart.data?.datasets?.[idx]?.data||[]; 
      const n=countRunsOverThreshold(dataArr, thresholdY); 
      const countEl=$('count'); 
      if(countEl && Number.isFinite(n)) countEl.value=n; 
    }

    function onDisconnected() {
      // 接続状態のフラグをクリア
      rxChar = undefined;
      txChar = undefined;
      bleDevice = undefined;

      // UI の状態を初期化
      $('now').textContent   = '未接続';
      $('timer').textContent = '停止中';
      $('start').disabled    = true;
      $('stop').disabled     = true;
      $('reset').disabled    = true;
      $('connect').disabled    = false;

      // タイマーを止める
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = null;

      // ログに表示
      const el = $('output');
      el.textContent += '[情報] デバイスが切断されました\n';
      el.scrollTop = el.scrollHeight;

      setMeasuring(false);
    }

    function resetChartData() {
      if (!chartInitialized) return;
      chart.data.labels.length = 0;
      chart.data.datasets.forEach(ds => ds.data.length = 0);
      chart.update('none');
    }

    $('reset').onclick = resetApp;

    // === リセットボタンの実装 ===
    function resetApp() {
      try {
        if (bleDevice?.gatt?.connected) bleDevice.gatt.disconnect();
      } catch {}

      // 既存のUI復帰関数（実装済み）を呼ぶ
      onDisconnected();

      // 既定値に戻す
      thresholdY = 1.25;
      $('axis').value = 'all';
      $('threshold').value = thresholdY.toFixed(2);
      $('thLabel').textContent = thresholdY.toFixed(2);
      $('count').value = '10';
      $('duration').value = '1';
      $('machine_duration').value = '10';
      $('connect').disabled = false;

      // ログと内部状態をクリア
      $('output').textContent = '';
      dataLog = [];
      ackQueue = [];
      isSendingAck = false;

      // グラフを初期状態へ
      resetChartData();
      $('rxCount').textContent = '0';
      $('timer').textContent = '停止中';
      $('now').textContent = '未接続';
      
    }

  </script>
</body>
</html>
