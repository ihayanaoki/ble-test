<!DOCTYPE html>
<html lang="ja">
<head>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <meta charset="UTF-8">
  <title>BLE加速度データ受信</title>
</head>
<body>
  <button id="start">スタート</button>
  <button id="stop">ストップ</button>
  <pre id="output"></pre>
  <canvas id="chart" width="400" height="200"></canvas>

  <script>
    let bleDevice, rxChar, txChar;
    let dataLog = [];

    // ACK送信用のキュー追加
    let ackQueue = [];
    let isSendingAck = false;

    document.getElementById("start").onclick = async () => {
      try {
        await connect();
        await sendCommand("START");
        dataLog = [];
        display("[開始コマンド送信]");
      } catch (err) {
        display("[エラー] " + err.message);
      }
    };

    document.getElementById("stop").onclick = async () => {
      await sendCommand("STOP");
      display("[停止コマンド送信]");
    };

    function display(msg) {
      document.getElementById("output").textContent += msg + "\n";
    }

    async function connect() {
      bleDevice = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: "XIAO" }],
        optionalServices: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"]
      });

      const server = await bleDevice.gatt.connect();
      const service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
      rxChar = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
      txChar = await service.getCharacteristic("6e400002-b5a3-f393-e0a9-e50e24dcca9e");

      await rxChar.startNotifications();
      rxChar.addEventListener("characteristicvaluechanged", handleReceive);
    }

    // ACKをキューに入れて送信（重要）
    async function queueAck() {
      ackQueue.push("ACK");
      processAckQueue();
    }

    async function processAckQueue() {
      if (isSendingAck || ackQueue.length === 0) return;

      isSendingAck = true;
      const encoder = new TextEncoder();

      while (ackQueue.length > 0) {
        try {
          await txChar.writeValue(encoder.encode(ackQueue.shift() + "\n"));
          await new Promise(res => setTimeout(res, 20)); // 安定のための短い待機
        } catch (err) {
          console.error("ACK送信エラー:", err);
        }
      }

      isSendingAck = false;
    }

    async function sendCommand(text) {
      const encoder = new TextEncoder();
      await txChar.writeValue(encoder.encode(text + "\n"));
    }

    async function handleReceive(event) {
      const data = event.target.value;
      const byteLength = data.byteLength;

      if (byteLength === 6) {
        const dv = new DataView(data.buffer);
        const ax = dv.getInt16(0, false) / 100.0;
        const ay = dv.getInt16(2, false) / 100.0;
        const az = dv.getInt16(4, false) / 100.0;

        dataLog.push({ ax, ay, az });
        queueAck();
        return;

      }

      const value = new TextDecoder().decode(event.target.value).trim();

      if (value === "STARTED") {
        display("[XIAO] 計測開始");
      } else if (value === "STOPPED") {
        display("[XIAO] 計測停止");
      } else if (value === "ENDED") {
        display("データ受信完了！");

        if (dataLog.length === 0) {
          display("[警告] 受信データがありません。");
          return;
        }

        // 各軸の最大・最小と行番号
        let maxX = -Infinity, minX = Infinity, maxXRow = -1, minXRow = -1;
        let maxY = -Infinity, minY = Infinity, maxYRow = -1, minYRow = -1;
        let maxZ = -Infinity, minZ = Infinity, maxZRow = -1, minZRow = -1;

        dataLog.forEach((row, idx) => {
          if (row.ax > maxX) { maxX = row.ax; maxXRow = idx; }
          if (row.ax < minX) { minX = row.ax; minXRow = idx; }
          if (row.ay > maxY) { maxY = row.ay; maxYRow = idx; }
          if (row.ay < minY) { minY = row.ay; minYRow = idx; }
          if (row.az > maxZ) { maxZ = row.az; maxZRow = idx; }
          if (row.az < minZ) { minZ = row.az; minZRow = idx; }
        });

        // 表示用HTML生成
        let html = '';
        dataLog.forEach((row, idx) => {
          const format = (val, isMax, isMin) => {
            if (isMax) return `<span style="color:red">${val.toFixed(2)}</span>`;
            if (isMin) return `<span style="color:blue">${val.toFixed(2)}</span>`;
            return val.toFixed(2);
          };

          const xVal = format(row.ax, idx === maxXRow, idx === minXRow);
          const yVal = format(row.ay, idx === maxYRow, idx === minYRow);
          const zVal = format(row.az, idx === maxZRow, idx === minZRow);

          html += `x:${xVal} y:${yVal} z:${zVal}<br>`;
        });

        document.getElementById("output").innerHTML += html;

        if (dataLog.length === 0) {
          display("[警告] 受信データがありません。");
          return;
        }

        // === 最大・最小値の処理は省略せずにこのまま（前回の回答を使用） ===
        // ...最大・最小値の計算＆色付き表表示の処理...

        // === Chart.js グラフ描画 ===
        // 既存のグラフがあれば削除
        if(window.myChart) {
          window.myChart.destroy();
        }

        const labels = dataLog.map((_, i) => i + 1);
        const xData = dataLog.map(d => d.ax);
        const yData = dataLog.map(d => d.ay);
        const zData = dataLog.map(d => d.az);

        const ctx = document.getElementById('chart').getContext('2d');
        window.myChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              { label: 'X', data: xData, borderColor: 'red', fill: false },
              { label: 'Y', data: yData, borderColor: 'green', fill: false },
              { label: 'Z', data: zData, borderColor: 'blue', fill: false }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true },
              tooltip: { enabled: true }
            },
            scales: {
              y: {
                suggestedMin: -2,
                suggestedMax: 2,
                title: { display: true, text: '加速度 (g)' }
              },
              x: {
                title: { display: true, text: 'データ番号' }
              }
            }
          }
        });
      } else if (value.startsWith("ERROR")) {
        display("[エラー] " + value);
      } else {
        console.warn("未知の文字列データ:", value);
      }
    }
  </script>
</body>
</html>