<!DOCTYPE html>
<html lang="ja">
<head>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <meta charset="UTF-8">
  <title>BLE加速度データ受信</title>
</head>
<body>
  <div class="button-row">
    <button id="start" class="main-btn start-btn">スタート</button>
    <button id="stop" class="main-btn stop-btn">ストップ</button>
  </div>
  <div id="timer"></div>
  <div id="now"></div>
  <canvas id="chart" width="400" height="200"></canvas>
  <pre id="output"></pre>

  <script>
    let bleDevice, rxChar, txChar;
    let dataLog = [];

    // ACK送信用のキュー追加
    let ackQueue = [];
    let isSendingAck = false;

    let chartInitialized = false;
    let chart;

    window.onload = () => {
      document.getElementById("start").disabled = false;
      document.getElementById("stop").disabled = true;
    };

    function initChart() {
      if(chart) chart.destroy();

      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'X', data: [], borderColor: 'red', fill: false },
            { label: 'Y', data: [], borderColor: 'green', fill: false },
            { label: 'Z', data: [], borderColor: 'blue', fill: false }
          ]
        },
        options: {
          animation: false, // アニメーションを切ってレスポンス優先
          scales: { y: { suggestedMin: -2, suggestedMax: 2 } }
        }
      });
      chartInitialized = true;
    }

    let startTime = null;

    document.getElementById("start").onclick = async () => {
      try {
        await connect();
        await sendCommand("START");
        dataLog = [];
        display("[開始コマンド送信]");
        startTime = Date.now(); // ← 開始時刻記録
        document.getElementById("timer").textContent = "計測中: 0秒";
        startTimerInterval();

        document.getElementById("start").disabled = true;
        document.getElementById("stop").disabled = false;
      } catch (err) {
        display("[エラー] " + err.message);
      }
    };

    document.getElementById("stop").onclick = async () => {
      await sendCommand("STOP");
      display("[停止コマンド送信]");
      stopTimerInterval();

      document.getElementById("stop").disabled = true;
    };

    let timerInterval = null;
    function startTimerInterval() {
      stopTimerInterval(); // 2重起動防止
      timerInterval = setInterval(() => {
        if (startTime) {
          const now = Date.now();
          const elapsed = Math.floor((now - startTime) / 1000);
          document.getElementById("timer").textContent = `計測中: ${elapsed}秒`;
        }
      }, 200);
    }
    function stopTimerInterval() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function display(msg) {
      document.getElementById("output").textContent += msg + "\n";
    }

    async function connect() {
      bleDevice = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: "XIAO" }],
        optionalServices: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"]
      });

      const server = await bleDevice.gatt.connect();
      const service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
      rxChar = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
      txChar = await service.getCharacteristic("6e400002-b5a3-f393-e0a9-e50e24dcca9e");

      await rxChar.startNotifications();
      rxChar.addEventListener("characteristicvaluechanged", handleReceive);
    }

    // ACKをキューに入れて送信（重要）
    async function queueAck() {
      ackQueue.push("ACK");
      processAckQueue();
    }

    async function processAckQueue() {
      if (isSendingAck || ackQueue.length === 0) return;

      isSendingAck = true;
      const encoder = new TextEncoder();

      while (ackQueue.length > 0) {
        try {
          await txChar.writeValue(encoder.encode(ackQueue.shift() + "\n"));
          await new Promise(res => setTimeout(res, 20)); // 安定のための短い待機
        } catch (err) {
          console.error("ACK送信エラー:", err);
        }
      }

      isSendingAck = false;
    }

    async function sendCommand(text) {
      const encoder = new TextEncoder();
      await txChar.writeValue(encoder.encode(text + "\n"));
    }

    async function handleReceive(event) {
      const data = event.target.value;
      const byteLength = data.byteLength;

      if (byteLength === 6) {
        const dv = new DataView(data.buffer);
        const ax = dv.getInt16(0, false) / 100.0;
        const ay = dv.getInt16(2, false) / 100.0;
        const az = dv.getInt16(4, false) / 100.0;

        dataLog.push({ ax, ay, az });

        // グラフがなければ初期化
        if(!chartInitialized) initChart();

        // 1件ずつデータ追加
        chart.data.labels.push(dataLog.length);
        chart.data.datasets[0].data.push(ax);
        chart.data.datasets[1].data.push(ay);
        chart.data.datasets[2].data.push(az);
        chart.update();

        
        queueAck();
        return;

      }

      const value = new TextDecoder().decode(event.target.value).trim();

      if (value === "STARTED") {
        display("[XIAO] 計測開始");
      } else if (value === "STOPPED") {
        display("[XIAO] 計測停止");
      } else if (value === "ENDED") {
        display("データ受信完了！");

        if (dataLog.length === 0) {
          display("[警告] 受信データがありません。");
          return;
        }

        // 各軸の最大・最小と行番号
        let maxX = -Infinity, minX = Infinity, maxXRow = -1, minXRow = -1;
        let maxY = -Infinity, minY = Infinity, maxYRow = -1, minYRow = -1;
        let maxZ = -Infinity, minZ = Infinity, maxZRow = -1, minZRow = -1;

        dataLog.forEach((row, idx) => {
          if (row.ax > maxX) { maxX = row.ax; maxXRow = idx; }
          if (row.ax < minX) { minX = row.ax; minXRow = idx; }
          if (row.ay > maxY) { maxY = row.ay; maxYRow = idx; }
          if (row.ay < minY) { minY = row.ay; minYRow = idx; }
          if (row.az > maxZ) { maxZ = row.az; maxZRow = idx; }
          if (row.az < minZ) { minZ = row.az; minZRow = idx; }
        });

        // 表示用HTML生成
        let html = '';
        dataLog.forEach((row, idx) => {
          const format = (val, isMax, isMin) => {
            if (isMax) return `<span style="color:red">${val.toFixed(2)}</span>`;
            if (isMin) return `<span style="color:blue">${val.toFixed(2)}</span>`;
            return val.toFixed(2);
          };

          const xVal = format(row.ax, idx === maxXRow, idx === minXRow);
          const yVal = format(row.ay, idx === maxYRow, idx === minYRow);
          const zVal = format(row.az, idx === maxZRow, idx === minZRow);

          html += `x:${xVal} y:${yVal} z:${zVal}<br>`;
        });

        document.getElementById("output").innerHTML += html;

        if (dataLog.length === 0) {
          display("[警告] 受信データがありません。");
          return;
        }

        // === 最大・最小値の処理は省略せずにこのまま（前回の回答を使用） ===
        // ...最大・最小値の計算＆色付き表表示の処理...

        // === Chart.js グラフ描画 ===
      } else if (value.startsWith("ERROR")) {
        display("[エラー] " + value);
      } else {
        console.warn("未知の文字列データ:", value);
      }
    }
  </script>
</body>
<style>
  .button-row {
    display: flex;
    gap: 2em;
    margin-bottom: 1em;
    justify-content: center;
  }

  .main-btn {
    font-size: 2rem;
    padding: 0.7em 2.5em;
    border-radius: 1em;
    border: none;
    box-shadow: 0 3px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    font-weight: bold;
    transition: background 0.15s, color 0.15s, box-shadow 0.15s;
  }

  .start-btn {
    background: #20c659;
    color: #fff;
  }
  .start-btn:hover {
    background: #18a047;
  }

  .stop-btn {
    background: #d03b39;
    color: #fff;
  }
  .stop-btn:hover {
    background: #a22e29;
  }

  .main-btn:disabled {
    background: #cccccc !important;
    color: #fff !important;
    opacity: 0.6;
    cursor: not-allowed;
  }

</style>
</html>